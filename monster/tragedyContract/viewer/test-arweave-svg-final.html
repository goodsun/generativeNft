<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Arweave SVG with Working Filters</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #1a1a1a;
            color: #fff;
        }
        .container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
        }
        .svg-box {
            border: 1px solid #444;
            padding: 10px;
            background: #2a2a2a;
            border-radius: 8px;
        }
        .svg-box h3 {
            margin: 0 0 10px 0;
            color: #ff6b6b;
        }
        .svg-display {
            background: #000;
            padding: 10px;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 240px;
        }
        svg {
            max-width: 100%;
            height: auto;
        }
        select {
            width: 100%;
            padding: 5px;
            margin: 10px 0;
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        .controls label {
            display: block;
        }
        .composed {
            grid-column: span 2;
            border: 2px solid #ff6b6b;
        }
        .method-selector {
            margin-bottom: 20px;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 8px;
            border: 1px solid #444;
        }
        .method-selector label {
            margin-right: 20px;
        }
    </style>
</head>
<body>
    <h1>Arweave SVG with Working Filters</h1>
    
    <div class="method-selector">
        <h3>Filter Method:</h3>
        <label>
            <input type="radio" name="method" value="css" checked> CSS Filters
        </label>
        <label>
            <input type="radio" name="method" value="svg"> SVG Filter Definitions
        </label>
        <label>
            <input type="radio" name="method" value="group"> Group Wrapper
        </label>
    </div>
    
    <h2>Select Layers:</h2>
    <div class="controls">
        <label>
            Background (Arweave):
            <select id="bg-select"></select>
        </label>
        <label>
            Monster (Local):
            <select id="monster-select"></select>
        </label>
        <label>
            Item (Local):
            <select id="item-select"></select>
        </label>
        <label>
            Effect (Arweave):
            <select id="effect-select"></select>
        </label>
    </div>
    
    <div class="container">
        <div class="svg-box composed">
            <h3>Composed NFT</h3>
            <div id="composed-display" class="svg-display"></div>
        </div>
    </div>

    <script>
        // Background filters
        const backgroundFilters = {
            Bloodmoon: {
                css: 'hue-rotate(0deg) saturate(150%) brightness(110%) contrast(120%) sepia(30%)',
                matrix: '1.5 0.5 0.5 0 0 0.3 1.0 0.3 0 0 0.1 0.1 0.8 0 0 0 0 0 1 0',
                brightness: 1.1
            },
            Abyss: {
                css: 'hue-rotate(260deg) saturate(120%) brightness(70%) contrast(110%)',
                matrix: '0.5 0 0.5 0 0 0 0.7 0.3 0 0 0.2 0 1.0 0 0 0 0 0 1 0',
                brightness: 0.7
            },
            Decay: {
                css: 'hue-rotate(50deg) saturate(80%) brightness(90%) contrast(100%) sepia(40%)',
                matrix: '1.0 0.2 0 0 0 0.2 1.0 0.2 0 0 0 0.2 0.8 0 0 0 0 0 1 0',
                brightness: 0.9
            },
            Corruption: {
                css: 'hue-rotate(300deg) saturate(180%) brightness(95%) contrast(115%)',
                matrix: '1.2 0.3 0.5 0 0 0.5 0.8 0.5 0 0 0.3 0.2 1.3 0 0 0 0 0 1 0',
                brightness: 0.95
            },
            Venom: {
                css: 'hue-rotate(90deg) saturate(200%) brightness(105%) contrast(130%)',
                matrix: '0.8 0.2 0 0 0.1 0.2 1.5 0.2 0 0 0 0.3 0.7 0 0 0 0 0 1 0',
                brightness: 1.05
            },
            Void: {
                css: 'saturate(10%) brightness(80%) contrast(150%)',
                matrix: '0.33 0.33 0.33 0 0 0.33 0.33 0.33 0 0 0.33 0.33 0.33 0 0 0 0 0 1 0',
                brightness: 0.8
            },
            Inferno: {
                css: 'hue-rotate(15deg) saturate(170%) brightness(120%) contrast(110%) sepia(20%)',
                matrix: '1.5 0.3 0 0 0 0.5 1.2 0 0 0 0.2 0.1 0.8 0 0 0 0 0 1 0',
                brightness: 1.2
            },
            Frost: {
                css: 'hue-rotate(200deg) saturate(110%) brightness(115%) contrast(105%)',
                matrix: '0.8 0 0.2 0 0 0 0.9 0.1 0 0 0.2 0.1 1.3 0 0 0 0 0 1 0',
                brightness: 1.15
            },
            Ragnarok: {
                css: 'hue-rotate(20deg) saturate(140%) brightness(85%) contrast(125%) sepia(15%)',
                matrix: '1.3 0.3 0 0 0 0.3 0.9 0 0 0 0.1 0 0.8 0 0 0 0 0 1 0',
                brightness: 0.85
            },
            Shadow: {
                css: 'saturate(50%) brightness(60%) contrast(90%)',
                matrix: '0.5 0 0 0 0 0 0.5 0 0 0 0 0 0.5 0 0 0 0 0 1 0',
                brightness: 0.6
            }
        };

        // Data storage
        let backgroundData = {};
        let monsterData = {};
        let itemData = {};
        let effectData = {};
        
        async function fetchAndConvertToBase64(url) {
            try {
                const response = await fetch(url);
                const text = await response.text();
                const base64 = btoa(unescape(encodeURIComponent(text)));
                return `data:image/svg+xml;base64,${base64}`;
            } catch (error) {
                console.error('Failed to fetch and convert:', url, error);
                return url;
            }
        }
        
        async function loadData() {
            try {
                const [bgResponse, monsterResponse, itemResponse, effectResponse] = await Promise.all([
                    fetch('./background.json'),
                    fetch('./monster.json'),
                    fetch('./item.json'),
                    fetch('./effect.json')
                ]);
                
                backgroundData = await bgResponse.json();
                monsterData = await monsterResponse.json();
                itemData = await itemResponse.json();
                effectData = await effectResponse.json();
                
                populateSelect('bg-select', backgroundData);
                populateSelect('monster-select', monsterData);
                populateSelect('item-select', itemData);
                populateSelect('effect-select', effectData);
                
                updateDisplay();
                
            } catch (error) {
                console.error('Failed to load data:', error);
            }
        }
        
        function populateSelect(selectId, data) {
            const select = document.getElementById(selectId);
            select.innerHTML = '<option value="">None</option>';
            
            Object.keys(data).forEach(key => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = key;
                select.appendChild(option);
            });
        }
        
        async function updateDisplay() {
            const bgKey = document.getElementById('bg-select').value;
            const monsterKey = document.getElementById('monster-select').value;
            const itemKey = document.getElementById('item-select').value;
            const effectKey = document.getElementById('effect-select').value;
            const method = document.querySelector('input[name="method"]:checked').value;
            
            await displayComposed(bgKey, monsterKey, itemKey, effectKey, method);
        }
        
        async function displayComposed(bgKey, monsterKey, itemKey, effectKey, method) {
            let svg = '';
            const filter = bgKey ? backgroundFilters[bgKey] : null;
            let filterId = `filter-${bgKey}`;
            
            // Start SVG
            svg = `<svg viewBox="0 0 24 24" width="240" height="240" xmlns="http://www.w3.org/2000/svg">`;
            
            // Add filter definition if using SVG method
            if (method === 'svg' && filter) {
                svg += `
                    <defs>
                        <filter id="${filterId}">
                            <feColorMatrix type="matrix" values="${filter.matrix}"/>
                            <feComponentTransfer>
                                <feFuncR type="linear" slope="${filter.brightness}"/>
                                <feFuncG type="linear" slope="${filter.brightness}"/>
                                <feFuncB type="linear" slope="${filter.brightness}"/>
                            </feComponentTransfer>
                        </filter>
                    </defs>
                `;
            }
            
            // Start group if using group method
            if (method === 'group' && filter) {
                svg += `<g style="filter: ${filter.css}">`;
            }
            
            // Add layers
            if (bgKey && backgroundData[bgKey]) {
                svg += `<image href="${backgroundData[bgKey]}" x="0" y="0" width="24" height="24"/>`;
            }
            
            if (monsterKey && monsterData[monsterKey]) {
                const base64Url = await fetchAndConvertToBase64(monsterData[monsterKey]);
                if (method === 'css' && filter) {
                    svg += `<image href="${base64Url}" x="0" y="0" width="24" height="24" style="filter: ${filter.css}"/>`;
                } else if (method === 'svg' && filter) {
                    svg += `<image href="${base64Url}" x="0" y="0" width="24" height="24" filter="url(#${filterId})"/>`;
                } else {
                    svg += `<image href="${base64Url}" x="0" y="0" width="24" height="24"/>`;
                }
            }
            
            if (itemKey && itemData[itemKey]) {
                const base64Url = await fetchAndConvertToBase64(itemData[itemKey]);
                // Apply lighter filter to items
                if (method === 'css' && filter) {
                    const itemFilter = filter.css.replace(/(\d+)%/g, (match, num) => Math.round(parseInt(num) * 0.5) + '%');
                    svg += `<image href="${base64Url}" x="0" y="0" width="24" height="24" style="filter: ${itemFilter}"/>`;
                } else if (method === 'svg' && filter) {
                    svg += `<image href="${base64Url}" x="0" y="0" width="24" height="24" filter="url(#${filterId})" opacity="0.9"/>`;
                } else {
                    svg += `<image href="${base64Url}" x="0" y="0" width="24" height="24"/>`;
                }
            }
            
            if (effectKey && effectData[effectKey]) {
                svg += `<image href="${effectData[effectKey]}" x="0" y="0" width="24" height="24"/>`;
            }
            
            // Close group if using group method
            if (method === 'group' && filter) {
                svg += `</g>`;
            }
            
            // Close SVG
            svg += `</svg>`;
            
            if (bgKey || monsterKey || itemKey || effectKey) {
                document.getElementById('composed-display').innerHTML = svg;
            } else {
                document.getElementById('composed-display').innerHTML = '<p>Select layers to compose</p>';
            }
        }
        
        // Event listeners
        document.getElementById('bg-select').addEventListener('change', updateDisplay);
        document.getElementById('monster-select').addEventListener('change', updateDisplay);
        document.getElementById('item-select').addEventListener('change', updateDisplay);
        document.getElementById('effect-select').addEventListener('change', updateDisplay);
        document.querySelectorAll('input[name="method"]').forEach(radio => {
            radio.addEventListener('change', updateDisplay);
        });
        
        // Load data on page load
        loadData();
    </script>
</body>
</html>